<section>
<canvas id="glCanvas" width="1000" height="520"></canvas>
<div class="overlay noselect" id="overlay">
  <div class="logo">
    <img class="bg" src="{{ $.Site.BaseURL }}img/logo.svg" alt=""/>
    <h1>Black Sphere Studios</h1>
    <div></div>
    <img class="tagline" src="{{ $.Site.BaseURL }}img/tagline.svg" alt=""/>
  </div>
</div>
</section>
<section class="projects">
  <div class="current"></div><div></div><div></div>
</section>

<script id="default-shader-fs" type="x-shader/x-fragment">   
  void main(void) { gl_FragColor = vec4(1,1,1,1); }
</script>
<script id="default-shader-vs" type="x-shader/x-vertex">
attribute vec3 Position;

uniform mat4 ModelMat;
uniform mat4 PMat;

void main(void) { gl_Position = PMat * ModelMat * vec4(Position, 1.0); }
</script>
<script id="texture-shader-fs" type="x-shader/x-fragment">  
  varying highp vec2 vTexCoord;
  uniform sampler2D s0; 
  uniform lowp vec4 Color;
  
  void main(void) { gl_FragColor = texture2D(s0,vTexCoord)*Color; }
</script>
<script id="texture-shader-vs" type="x-shader/x-vertex">
attribute vec3 Position;
attribute vec2 TexCoord;

uniform mat4 ModelMat;
uniform mat4 PMat;

varying highp vec2 vTexCoord;

void main(void) {
  gl_Position = PMat * ModelMat * vec4(Position, 1.0);
  vTexCoord=TexCoord;
}
</script>
<script id="digital-ocean-fs" type="x-shader/x-fragment"> 
  varying lowp vec4 vColor;  

  void main(void)
  { 
    gl_FragColor = vColor;
  }
</script>
<script id="digital-ocean-vs" type="x-shader/x-vertex">
  attribute vec3 Position;
    
  uniform mat4 ModelMat;
  uniform mat4 PMat;
  uniform float Time;
  
  varying lowp vec4 vColor;
  const float PI = 3.141592653589;
  
  float wave(float L, float A, float S, vec2 D, vec3 pos) {
    float w = (2.0*PI)/L;
    w = (sin(dot(normalize(D),vec2(pos.x,pos.z))*w + Time*(S*w))+1.0)*0.5;
    return A*(w*w-1.0)*2.0;
  }
  float addy(vec3 pos) {
    float y=wave(10.0,0.15,0.001,vec2(1.0,2.0),pos);
    y+=wave(5.0,0.1,0.0005,vec2(1.0,1.0),pos);
    y+=wave(20.0,0.15,0.002,vec2(-1.0,1.0),pos);
    y+=wave(20.0,0.15,0.0015,vec2(-1.2,-1.0),pos);
    y+=wave(40.0,0.75,0.0005,vec2(1.9,-1.0),pos);
    return y;
  }
  void main(void) {
    vec3 pos = Position;
    pos.y+=addy(pos);
    //vec3 pos2 = vec3(pos.x+1.0,pos.y,pos.z);
    //pos2.y+=addy(pos2);
    //vec3 pos3 = vec3(pos.x,pos.y,pos.z-1.0);
    //pos3.y+=addy(pos3);
    
    //vec3 normal = cross(pos2-pos,pos3-pos);
    //normal = normalize(vec3(normal.x,0,normal.z));
    //float spec = dot(normal,normalize(vec3(1,1,0.1)));
    vec3 color = mix(vec3(0.19,0.06,0.41),vec3(0.46,0.45,1),pos.y*(0.5)+1.0);
    gl_Position = PMat * ModelMat * vec4(pos, 1.0);
    pos = vec3(gl_Position.x,0,gl_Position.z);
    color*=sqrt(100.0/dot(pos,pos));
    
    vColor=vec4(color,1.0);
  }
</script>
<script type="text/javascript" src="sylvester.js"></script>
<script type="text/javascript" src="glUtils.js"></script>
<script type="text/javascript" src="TinyWGL.js"></script>
<script type="text/javascript">
"use strict";

function Grid(w,h,tinywgl, type, shader, renderfn)
{
  var vertices = [];
  var num=w*h;
  for(var i = 0; i < num; ++i)
  {
    vertices[3*i]=1.0*(~~(i%w)); // Stupid dynamically typed languages.
    vertices[(3*i)+1]=0;
    vertices[(3*i)+2]=-1.0*(~~(i/w)); // Seriously what the fuck
  }
  var indices = [];
  var k=0;
  var len;
  for(var j = 0; j < (h-1); ++j)
  {
    len=(j*w)+w-1;
    for(var i = (j*w); i < len; ++i)
    {
      indices[k++] = i;
      indices[k++] = i+1;
      indices[k++] = i;
      indices[k++] = i+w; // This bumps us down to the next row
    }
    indices[k++] = len; // Gets the right edge
    indices[k++] = len+w;
  }
  j=(h-1);
  len=(j*w)+w-1;
  for(var i = (j*w); i < len; ++i)// Gets the bottom edge
  {
    indices[k++] = i;
    indices[k++] = i+1;
  }
  
  TinyRenderable.call(this, type, shader, tinywgl.createVertexBuffer(vertices, 3), tinywgl.createIndexBuffer(indices), {}, renderfn);
}

function init() {
  var tinywgl = new TinyWGL(document.getElementById("glCanvas"), 1000.0, 60, function(c) {
    var w = document.documentElement.clientWidth || document.body.clientWidth;
    c.width = ((w < 400) ? 400 : w);
    c.height = Math.floor(Math.min(520.0, c.width*(520.0/1130.0)));
    document.getElementById("overlay").style.height = ~~c.height + "px";
  });
  if(!tinywgl.gl) return;
  
  // First visualization
  var OCEANSIZE = 200;
  var ocean = new Grid(OCEANSIZE,OCEANSIZE,tinywgl, tinywgl.gl.LINES,
    tinywgl.createShader("digital-ocean-fs","digital-ocean-vs",
      {"PMat" : tinywgl.Mat4x4,
       "ModelMat" : tinywgl.Mat4x4,
       "Time" : tinywgl.Float1 },
      [["Position",3,12,0]]),
    function(wgl) { this.params["ModelMat"]=Matrix.Translation($V([-OCEANSIZE/2, 0, -2.5])).ensure4x4();
      this.params["PMat"] = tinywgl.perspectiveCameraMatrix;
      this.params["Time"] = tinywgl.time+100000.0; }
  );
  tinywgl.pass[0].renderables.push(ocean);
  tinywgl.pass[0].onDraw = function() {
    var pos = [Math.sin(tinywgl.time/7500.0)*0.5,1,Math.atan(tinywgl.time/10000.0)*-15];
    //pos = 1;
    this.cameraMatrix = makeLookAt(pos[0],pos[1],pos[2],pos[0]*2,pos[1],pos[2]-2,0,1,0);
  };
  
  tinywgl.draw();
  document.getElementById("overlay").className += " active"
}
</script>
<script id="shader-fs" type="x-shader/x-fragment">
  void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>